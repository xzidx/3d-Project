<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D Hand-Tracked Block Maker</title>
<style>
body { margin:0; overflow:hidden; background:black; }
video { display:none; }
canvas { position:absolute; width:100vw; height:100vh; top:0; left:0; }
#threeCanvas { position:absolute; width:100vw; height:100vh; top:0; left:0; pointer-events:none; }
</style>
</head>
<body>

<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>
<canvas id="threeCanvas"></canvas>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

<script>
// ---------- DOM ----------
const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// ---------- START CAMERA ----------
async function startCamera() {
  const stream = await navigator.mediaDevices.getUserMedia({ video: { width:640, height:480 } });
  video.srcObject = stream;
  await video.play();
}
startCamera();

// ---------- THREE.js ----------
const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById("threeCanvas"), alpha:true, antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(15,20,25);
camera.lookAt(0,0,0);

scene.add(new THREE.AmbientLight(0xffffff,0.6));
const dirLight = new THREE.DirectionalLight(0xffffff,0.8);
dirLight.position.set(30,40,30);
scene.add(dirLight);

scene.add(new THREE.GridHelper(50,50));

const voxelGroup = new THREE.Group();
scene.add(voxelGroup);
const voxels = {};

// ---------- Hover Cube ----------
const hoverCube = new THREE.Mesh(
  new THREE.BoxGeometry(1,1,1),
  new THREE.MeshStandardMaterial({ color:0xff0000, transparent:true, opacity:0.4, emissive:0xff0000 })
);
scene.add(hoverCube);

// ---------- MediaPipe Hands ----------
const hands = new Hands({ locateFile: f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${f}` });
hands.setOptions({ maxNumHands:2, modelComplexity:1, minDetectionConfidence:0.7, minTrackingConfidence:0.7 });
let handResults = null;
hands.onResults(results => handResults = results);

async function trackHands(){
  if(video.readyState >= 2) await hands.send({ image: video });
  requestAnimationFrame(trackHands);
}
trackHands();

// ---------- Helpers ----------
function screenToWorld(nx, ny, distance=10){
  const x = (nx-0.5)*2;
  const y = -(ny-0.5)*2;
  const vec = new THREE.Vector3(x,y,0.5);
  vec.unproject(camera);
  const dir = vec.clone().sub(camera.position).normalize();
  return camera.position.clone().add(dir.multiplyScalar(distance));
}
function snapToGrid(pos){
  return new THREE.Vector3(Math.round(pos.x), Math.round(pos.y), Math.round(pos.z));
}

// ---------- Keyboard Controls ----------
const keys = {ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false};
const moveSpeed = 0.5;
const rotateSpeed = 0.03;

document.addEventListener('keydown', e=>{
  if(keys.hasOwnProperty(e.key)) keys[e.key] = true;
  if(e.key==='w') voxelGroup.position.z -= moveSpeed;
  if(e.key==='s') voxelGroup.position.z += moveSpeed;
  if(e.key==='a') voxelGroup.position.x -= moveSpeed;
  if(e.key==='d') voxelGroup.position.x += moveSpeed;
});

document.addEventListener('keyup', e=>{
  if(keys.hasOwnProperty(e.key)) keys[e.key] = false;
});

// ---------- Block Placement ----------
let lastBlockTime = 0;
const cooldown = 300;

// ---------- Main Animate Loop ----------
function animate(){
  requestAnimationFrame(animate);

  // Rotate while arrow keys pressed
  if(keys.ArrowUp) voxelGroup.rotation.x -= rotateSpeed;
  if(keys.ArrowDown) voxelGroup.rotation.x += rotateSpeed;
  if(keys.ArrowLeft) voxelGroup.rotation.y -= rotateSpeed;
  if(keys.ArrowRight) voxelGroup.rotation.y += rotateSpeed;

  // Draw webcam
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(video.readyState >= 2) ctx.drawImage(video,0,0,canvas.width,canvas.height);

  // Process hand
  if(handResults && handResults.multiHandLandmarks){
    handResults.multiHandLandmarks.forEach(hand=>{
      const indexTip = hand[8], thumbTip = hand[4];
      const dx=indexTip.x-thumbTip.x, dy=indexTip.y-thumbTip.y, dz=indexTip.z-thumbTip.z;
      const dist=Math.sqrt(dx*dx+dy*dy+dz*dz);

      // Calculate position relative to voxel group
      let pos = screenToWorld(indexTip.x,indexTip.y,10);
      pos = snapToGrid(pos);
      hoverCube.position.copy(pos);

      // Place block
      if(dist < 0.05){
        const now = performance.now();
        if(now - lastBlockTime > cooldown){
          lastBlockTime = now;
          const key = `${pos.x},${pos.y},${pos.z}`;
          if(!voxels[key]){
            const geometry = new THREE.BoxGeometry(1,1,1);
            const material = new THREE.MeshStandardMaterial({ color:0xff0000, emissive:0xff0000, emissiveIntensity:0.8 });
            const cube = new THREE.Mesh(geometry,material);

            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges,new THREE.LineBasicMaterial({color:0xff0000}));
            cube.add(line);

            // Add block **inside voxel group** so rotation/move works correctly
            cube.position.copy(pos);
            voxelGroup.add(cube);
            voxels[key] = cube;
          }
        }
      }
    });
  }

  renderer.render(scene,camera);
}
animate();

// ---------- Resize ----------
window.addEventListener('resize',()=>{
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  renderer.setSize(window.innerWidth,window.innerHeight);
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
});
</script>

</body>
</html>
